package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"book-nexus/graph/model"
	"book-nexus/internal/database/sqlc"
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// Books is the resolver for the books field.
func (r *authorResolver) Books(ctx context.Context, obj *model.Author) ([]*sqlc.Book, error) {
	q := sqlc.New(r.DB.DB())
	books, err := q.GetBooksByAuthor(ctx, obj.Name)
	if err != nil {
		return nil, err
	}
	var result []*sqlc.Book
	for _, b := range books {
		b := b
		result = append(result, &b)
	}
	return result, nil
}

// ID is the resolver for the id field.
func (r *bookResolver) ID(ctx context.Context, obj *sqlc.Book) (string, error) {
	return obj.ID.String(), nil
}

// Author is the resolver for the author field.
func (r *bookResolver) Author(ctx context.Context, obj *sqlc.Book) (*model.Author, error) {
	return &model.Author{Name: obj.Author}, nil
}

// PublishedDate is the resolver for the publishedDate field.
func (r *bookResolver) PublishedDate(ctx context.Context, obj *sqlc.Book) (*string, error) {
	if obj.PublishedDate == nil {
		return nil, nil
	}
	s := obj.PublishedDate.Format("2006-01-02")
	return &s, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *bookResolver) CreatedAt(ctx context.Context, obj *sqlc.Book) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *bookResolver) UpdatedAt(ctx context.Context, obj *sqlc.Book) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// Recommendations is the resolver for the recommendations field.
func (r *bookResolver) Recommendations(ctx context.Context, obj *sqlc.Book) ([]*sqlc.Book, error) {
	panic(fmt.Errorf("not implemented: Recommendations - recommendations"))
}

// CreateBook is the resolver for the createBook field.
func (r *mutationResolver) CreateBook(ctx context.Context, input model.NewBook) (*sqlc.Book, error) {
	q := sqlc.New(r.DB.DB())

	var publishedDate *time.Time
	if input.PublishedDate != nil {
		t, err := time.Parse("2006-01-02", *input.PublishedDate)
		if err != nil {
			return nil, fmt.Errorf("invalid date format: %v", err)
		}
		publishedDate = &t
	}

	arg := sqlc.CreateBookParams{
		Title:         input.Title,
		Subtitle:      input.Subtitle,
		Author:        input.Author,
		Publisher:     input.Publisher,
		PublishedDate: publishedDate,
		Isbn10:        input.Isbn10,
		Isbn13:        input.Isbn13,
		Language:      input.Language,
		Description:   input.Description,
		SeriesName:    input.SeriesName,
		Genres:        input.Genres,
		Tags:          input.Tags,
		ImageUrl:      input.ImageURL,
	}

	if input.Pages != nil {
		p := int32(*input.Pages)
		arg.Pages = &p
	}
	if input.SeriesPosition != nil {
		p := int32(*input.SeriesPosition)
		arg.SeriesPosition = &p
	}

	book, err := q.CreateBook(ctx, arg)
	if err != nil {
		return nil, err
	}
	return &book, nil
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context) ([]*sqlc.Book, error) {
	q := sqlc.New(r.DB.DB())
	// Default limit/offset
	books, err := q.ListBooks(ctx, sqlc.ListBooksParams{
		Limit:  100,
		Offset: 0,
	})
	if err != nil {
		return nil, err
	}
	var result []*sqlc.Book
	for _, b := range books {
		b := b
		result = append(result, &b)
	}
	return result, nil
}

// Book is the resolver for the book field.
func (r *queryResolver) Book(ctx context.Context, id string) (*sqlc.Book, error) {
	q := sqlc.New(r.DB.DB())
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid UUID: %v", err)
	}
	book, err := q.GetBookByID(ctx, uid)
	if err != nil {
		return nil, err
	}
	return &book, nil
}

// Authors is the resolver for the authors field.
func (r *queryResolver) Authors(ctx context.Context, search *string) ([]*model.Author, error) {
	q := sqlc.New(r.DB.DB())
	var authors []string
	var err error
	if search != nil {
		authors, err = q.SearchAuthors(ctx, search)
	} else {
		authors, err = q.ListAuthors(ctx)
	}
	if err != nil {
		return nil, err
	}

	var result []*model.Author
	for _, a := range authors {
		result = append(result, &model.Author{Name: a})
	}
	return result, nil
}

// SearchBooks is the resolver for the searchBooks field.
func (r *queryResolver) SearchBooks(ctx context.Context, input model.SearchBooksInput) (*model.SearchResult, error) {
	q := sqlc.New(r.DB.DB())

	// Convert pointer fields to string values (nil becomes empty string)
	var title string
	if input.Query != nil {
		title = *input.Query
	}
	var author string
	if input.Author != nil {
		author = *input.Author
	}
	var publisher string
	if input.Publisher != nil {
		publisher = *input.Publisher
	}
	var series string
	if input.Series != nil {
		series = *input.Series
	}

	// Default values for pagination and sorting
	sortBy := "created_at"
	if input.SortBy != nil {
		sortBy = *input.SortBy
	}
	limit := int32(20)
	if input.Limit != nil {
		limit = *input.Limit
	}
	offset := int32(0)
	if input.Offset != nil {
		offset = *input.Offset
	}

	// Search books
	books, err := q.SearchBooks(ctx, sqlc.SearchBooksParams{
		Column1: title,
		Column2: author,
		Column3: publisher,
		Column4: series,
		Column5: sortBy,
		Limit:   limit,
		Offset:  offset,
	})
	if err != nil {
		return nil, fmt.Errorf("search books: %v", err)
	}

	// Get total count
	count, err := q.CountSearchResults(ctx, sqlc.CountSearchResultsParams{
		Column1: title,
		Column2: author,
		Column3: publisher,
		Column4: series,
	})
	if err != nil {
		return nil, fmt.Errorf("count results: %v", err)
	}

	// Convert books to pointers
	var bookPtrs []*sqlc.Book
	for i := range books {
		bookPtrs = append(bookPtrs, &books[i])
	}

	return &model.SearchResult{
		Books: bookPtrs,
		Total: int32(count),
	}, nil
}

// Series is the resolver for the series field.
func (r *queryResolver) Series(ctx context.Context, id string) (*model.Series, error) {
	q := sqlc.New(r.DB.DB())

	// Get series details - id parameter is the series name
	seriesName := id
	series, err := q.GetSeriesByName(ctx, &seriesName)
	if err != nil {
		return nil, fmt.Errorf("get series: %v", err)
	}

	// Handle case where series doesn't exist
	if series.Name == nil {
		return nil, nil
	}

	// Get books in series
	books, err := q.GetBooksBySeries(ctx, series.Name)
	if err != nil {
		return nil, fmt.Errorf("get series books: %v", err)
	}

	// Convert books to pointers
	var bookPtrs []*sqlc.Book
	for i := range books {
		bookPtrs = append(bookPtrs, &books[i])
	}

	return &model.Series{
		ID:        *series.Name,
		Name:      *series.Name,
		Books:     bookPtrs,
		BookCount: int32(series.BookCount),
	}, nil
}

// SeriesList is the resolver for the seriesList field.
func (r *queryResolver) SeriesList(ctx context.Context) ([]*model.Series, error) {
	q := sqlc.New(r.DB.DB())

	seriesList, err := q.ListSeries(ctx)
	if err != nil {
		return nil, fmt.Errorf("list series: %v", err)
	}

	var result []*model.Series
	for _, s := range seriesList {
		if s.Name == nil {
			continue
		}
		result = append(result, &model.Series{
			ID:        *s.Name,
			Name:      *s.Name,
			BookCount: int32(s.BookCount),
		})
	}

	return result, nil
}

// Author returns AuthorResolver implementation.
func (r *Resolver) Author() AuthorResolver { return &authorResolver{r} }

// Book returns BookResolver implementation.
func (r *Resolver) Book() BookResolver { return &bookResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type authorResolver struct{ *Resolver }
type bookResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
